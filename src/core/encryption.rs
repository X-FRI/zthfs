use crate::config::EncryptionConfig;
use crate::errors::{ZthfsError, ZthfsResult};
use aes_gcm::aead::{Aead, KeyInit};
use aes_gcm::{Aes256Gcm, Key};
use crc32c::crc32c;
use generic_array::GenericArray;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use typenum::U12;

pub struct EncryptionHandler {
    cipher: Aes256Gcm,
    nonce_seed: Vec<u8>,
    nonce_cache: Arc<Mutex<HashMap<String, GenericArray<u8, U12>>>>,
}

impl EncryptionHandler {
    /// Create new encryption handler
    pub fn new(config: &EncryptionConfig) -> Self {
        let key = Key::<Aes256Gcm>::from_slice(&config.key);
        let cipher = Aes256Gcm::new(key);

        Self {
            cipher,
            nonce_seed: config.nonce_seed.clone(),
            nonce_cache: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    /// Generate unique nonce for file path.
    /// Nonce is generated by XORing the CRC32c checksum of the file path with the CRC32c checksum of the nonce_seed,
    /// and then filling the result into a 12-byte array. To improve performance, the generated nonce is cached, and the same path request will return the cached result directly.
    pub fn generate_nonce(&self, path: &str) -> GenericArray<u8, U12> {
        // Check cache
        if let Ok(cache) = self.nonce_cache.lock()
            && let Some(nonce) = cache.get(path)
        {
            return *nonce;
        }

        // Generate new nonce
        let hash = crc32c(path.as_bytes()) ^ crc32c(&self.nonce_seed);
        let mut nonce_bytes = [0u8; 12];
        nonce_bytes[..4].copy_from_slice(&hash.to_le_bytes());
        nonce_bytes[4..8].copy_from_slice(&hash.to_le_bytes());
        // Use low 4 bits of hash to fill last 4 bytes
        nonce_bytes[8..12].copy_from_slice(&hash.to_le_bytes());
        let nonce = GenericArray::from(nonce_bytes);

        // Cache nonce
        if let Ok(mut cache) = self.nonce_cache.lock() {
            cache.insert(path.to_string(), nonce);
        }

        nonce
    }

    pub fn encrypt(&self, data: &[u8], path: &str) -> ZthfsResult<Vec<u8>> {
        let nonce = self.generate_nonce(path);
        let ciphertext = self
            .cipher
            .encrypt(&nonce, data)
            .map_err(|e| ZthfsError::Crypto(format!("Encryption failed: {e:?}")))?;
        Ok(ciphertext)
    }

    pub fn decrypt(&self, data: &[u8], path: &str) -> ZthfsResult<Vec<u8>> {
        let nonce = self.generate_nonce(path);
        let plaintext = self
            .cipher
            .decrypt(&nonce, data)
            .map_err(|e| ZthfsError::Crypto(format!("Decryption failed: {e:?}")))?;
        Ok(plaintext)
    }

    /// Validate the validity of the encryption configuration, mainly checking the length of the key and nonce seed.
    pub fn validate_config(config: &EncryptionConfig) -> ZthfsResult<()> {
        if config.key.len() != 32 {
            return Err(ZthfsError::Config(
                "Encryption key must be 32 bytes".to_string(),
            ));
        }
        if config.nonce_seed.len() != 12 {
            return Err(ZthfsError::Config(
                "Nonce seed must be 12 bytes".to_string(),
            ));
        }
        Ok(())
    }

    /// Generate random encryption key
    pub fn generate_key() -> [u8; 32] {
        use rand::RngCore;
        let mut key = [0u8; 32];
        rand::thread_rng().fill_bytes(&mut key);
        key
    }

    /// Generate random nonce seed
    pub fn generate_nonce_seed() -> [u8; 12] {
        use rand::RngCore;
        let mut seed = [0u8; 12];
        rand::thread_rng().fill_bytes(&mut seed);
        seed
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encryption_decryption() {
        let config = EncryptionConfig::default();
        let encryptor = EncryptionHandler::new(&config);

        let test_data = b"Hello, medical data!";
        let path = "/test/file.txt";

        let encrypted = encryptor.encrypt(test_data, path).unwrap();
        let decrypted = encryptor.decrypt(&encrypted, path).unwrap();

        assert_eq!(test_data, decrypted.as_slice());
    }

    #[test]
    fn test_nonce_generation() {
        let config = EncryptionConfig::default();
        let encryptor = EncryptionHandler::new(&config);

        let path1 = "/test/file1.txt";
        let path2 = "/test/file2.txt";

        let nonce1 = encryptor.generate_nonce(path1);
        let nonce2 = encryptor.generate_nonce(path2);

        // Different paths should generate different nonces
        assert_ne!(nonce1, nonce2);
    }

    #[test]
    fn test_nonce_consistency() {
        let config = EncryptionConfig::default();
        let encryptor = EncryptionHandler::new(&config);

        let path = "/test/file.txt";

        let nonce1 = encryptor.generate_nonce(path);
        let nonce2 = encryptor.generate_nonce(path);

        // Same path should generate the same nonce
        assert_eq!(nonce1, nonce2);
    }

    #[test]
    fn test_config_validation() {
        // Invalid key length
        let config = EncryptionConfig {
            key: vec![1, 2, 3],
            ..Default::default()
        }; // 3 bytes instead of 32
        assert!(EncryptionHandler::validate_config(&config).is_err());

        // Restore valid configuration
        let config = EncryptionConfig::default();
        assert!(EncryptionHandler::validate_config(&config).is_ok());
    }

    #[test]
    fn test_key_generation() {
        let key = EncryptionHandler::generate_key();
        assert_eq!(key.len(), 32);

        let nonce_seed = EncryptionHandler::generate_nonce_seed();
        assert_eq!(nonce_seed.len(), 12);
    }
}
